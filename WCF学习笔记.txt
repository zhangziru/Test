我是皇上，我怕谁 2018/07/23 19:21:57
WCF是对现有Windows平台下通信技术的整合。
我是皇上，我怕谁 2018/07/25 08:51:37
WCF是用来在不同应用间进行互通信的一个编程框架。
我是皇上，我怕谁 2018/07/25 08:53:22
WCF是.NetFramework中偏重于通信的重要组成部分。
我是皇上，我怕谁 2018/07/25 19:23:53
SOA(Service-Oriented-Architecture),应用间通信
我是皇上，我怕谁 2018/07/25 19:26:33
WCF是一个统一化的通信编程开发模型。
我是皇上，我怕谁 2018/07/26 08:38:58
WCF是按照SOA的架构原则设计的分布式计算基础环境，在其上开发人员可以实现各种Service提供给客户端消费者来调用。WCF提供了各种各样的基础结构来最大程度地为开发人员提供方便性和灵活性，快速有效地构建WebService应用。
我是皇上，我怕谁 2018/07/26 19:03:52
核心的Web服务标准(SOAP和WSDL)逐渐被广泛的采纳和应用。
我是皇上，我怕谁 2018/07/26 19:12:21
.Net下分布式开发的技术:ASP.NET服务、Web服务增强、.Net Remoting、MSMQ等，这些技术各自独立，编程模型差异较大，无法用一种统一的编程模型进行分布式应用程序的开发。
我是皇上，我怕谁 2018/07/27 08:45:06
.Net Framework 3.0版本才有WCF
我是皇上，我怕谁 2018/07/27 08:52:45
编程中的一大问题:面对众多技术，“方言”往往会造成工作成果无法重用，WCF的出现可以使得全球开发人员使用一种。
我是皇上，我怕谁 2018/07/27 08:54:41
WCF的延展性和灵活性
我是皇上，我怕谁 2018/07/27 09:16:39
如何在软件设计之初就充分考虑软件的可扩展性，我觉得这是非常值得我们学习的。软件版本演进过程应该是对现有设计进行扩展的过程，而不是不断对现有设计进行否定与革新的过程。~蒋金楠
我是皇上，我怕谁 2018/08/01 18:59:31
WCF在你真正投入之前建议先好好学习一下SOA
我是皇上，我怕谁 2018/08/01 19:01:51
WCF书籍勘误以及资源下载:http://blog.csdn.net/bvbook
我是皇上，我怕谁 2018/08/01 19:07:47
.Net下分布式开发的技术:ASP.NET服务(XML Web Service)、Web服务增强(WSE)、.Net Remoting、MSMQ
我是皇上，我怕谁 2018/08/02 08:38:23
Web Services Enhancements 2.0 for Microsoft .NET (WSE)是一个用来建设Web服务的・NET类库，它支持最新的Web服务协议，包括WS-Security、WS-SecureConversation、WS-Trust、WS-Policy、WS-SecurityPolicy、WS-Addressing和 WS-Attachments。
我是皇上，我怕谁 2018/08/02 08:40:31
WSE可使开发人员跨安全平台建设可升级的、安全的Web服务。它支持的传输的方式用SOAP发送消息，而不是HTTP。
我是皇上，我怕谁 2018/08/02 08:47:46
不论是SOA，还是云计算，都需要解决一个核心的问题，那就是通信(Communition),而WCF解决的就是通信问题。WCF的“江湖地位”可想而知
我是皇上，我怕谁 2018/08/13 08:35:52
面向服务(SO:Service Orientation)代表的是一种设计理念，和面向对象(OO:Object Orientation)、面向组件CO(Component Orientation)一样，体现的是一种对关键点分解的思想，面向服务是和技术无关的。
我是皇上，我怕谁 2018/08/13 08:40:42
Web服务(这里指的是广义的Web服务，包括微软平台下的ASP.NET Web服务和WCF,也包含其它平台的Web服务)是一种实现SOA最理想的技术手段。
我是皇上，我怕谁 2018/08/13 08:44:12
危险思想:服务架构仅仅是由一堆web服务堆砌而成。
我是皇上，我怕谁 2018/08/14 08:35:21
SOA强调松耦合:基于类型系统交互方式面向组件的不同，SOA通过"契约"实现客户端对服务的调用。双方只需要采用能够匹配的契约，就能保证正常的交互。基于契约的服务交互，只要契约不发生改变，服务本身的变化可以自由实现。
我是皇上，我怕谁 2018/08/15 19:06:56
WCF本质上提供一个跨进程、跨机器以致跨网络的服务调用。
我是皇上，我怕谁 2018/08/15 19:11:33
WCF服务不能孤立的存在，须要寄宿于运行着的一个进程中，我们把承载WCF服务的进程称为宿主，为服务指定宿主的过程称为服务寄宿(Service Hosting)。
我是皇上，我怕谁 2018/08/16 08:34:46
在我们的计算服务应用中，采用了两种服务寄宿方式:1、通过自我寄宿(Self- Hosting)的方式创建一个控制台应用，作为服务的宿主（寄宿进程为Hosting.exe）；2、通过IIS寄宿方式将服务寄宿于IIS中(寄宿进程为IIS的工作进程W3wp.exe)。客户端通过另一个控制台应用模拟(进程为Client.exe)
我是皇上，我怕谁 2018/08/16 19:23:11
通过应用ServiceContractAttribute特性将接口定义成服务契约之后，接口的方法成员并不能自动成为服务的操作。在此方面，WCF采用的是显示选择的策略:我们须要在相应的操作方法上面显示地应用OperationContractAttribute特性。
我是皇上，我怕谁 2018/08/20 08:49:47
服务寄宿的目的:就是开启一个进程，为WCF提供一个运行的环境。通过为服务添加一个或多个终结点，使之暴露给潜在的服务消费者。服务消费者最后通过相匹配的终结点对该服务进行调用。[我们完全可以通过代码的方式完成所有服务寄宿的工作。]
我是皇上，我怕谁 2018/08/20 09:08:14
上述的代码:见WCF的pdf第38页
我是皇上，我怕谁 2018/08/21 08:34:23
WCF服务寄宿通过一个特殊的对象完成:ServiceHost。
我是皇上，我怕谁 2018/08/21 08:58:48
松耦合是SOA的一个基本特征，WCF应用中客户端和服务端的松耦合体现在客户端只需要了解WCF服务基本描述，而无须知道具体的实现细节，就可以实现正常的服务调用。
我是皇上，我怕谁 2018/08/21 09:29:16
WCF服务的描述通过元数据（Metadata）的形式发布出来。WCF中元数据的发布通过一个特殊的服务行为ServiceMetaBehavior来实现。
我是皇上，我怕谁 2018/08/21 10:02:02
通过代码来实现，我们为创建的ServiceHost添加了ServiceMetaBehavior,并才用了基于HTTP-GET的元数据获取方式，元数据的发布地址通过ServiceMetaBehavior的HttpGetUrl指定。
我是皇上，我怕谁 2018/08/21 12:30:08
【WCF实际应用中】一般不会通过编码的方式进行终结点的添加和服务行为的定义，而是通过配置的方式进行。添加终结点和定义服务行为的代码可以用一下代码配置:见WCF技术剖析P39。
我是皇上，我怕谁 2018/08/21 13:13:43
WCF的配置，对于初学者，可以通过可视化界面进行配置。你可以通过VS工具（Tools）菜单，通过选择“WCF Service Configuration Editor”子项，开启这样的一个配置编辑器。
我是皇上，我怕谁 2018/08/27 19:17:59
客户端通过服务代理对象进行服务的调用，继承自ClientBase<T>的类型对象进行服务调用。实际上，还有另外一种创建服务代理的方法，就是通过ChannelFactory<T>。
将客户端和服务端分开，借助于这个服务契约，并通过ChannelFactory<ICalculator>创建服务代理对象，直接进行相应的服务调用。代码:WCF技术解析P43
我是皇上，我怕谁 2018/08/28 08:50:01
在创建ChannelFactory<T>的时候，在构造函数中指定终结点的相关要素（契约通过泛型类型表示，地址和绑定则通过参数指定）。【ABC绑定】
我是皇上，我怕谁 2018/08/28 09:16:18
在真正的WCF中，大都采用配置的方式进行终结点的定义。配置代码见P44，并为配置的终结点指定一个名称name。这样在程序中就可以通过名称来创建ChannelFactory<T>,无需指定终结点相关要素。【代码配置终结点，以及程序中如何使用】
我是皇上，我怕谁 2018/08/30 19:54:59
基于IIS的服务寄宿要求相应的WCF服务具有相应的.svc文件，.svc文件部署于IIS站点中，对WCF服务的调用体现在对.svc文件的访问上。
我是皇上，我怕谁 2018/08/30 20:01:35
.svc文件的内容很简单，仅仅包含一个ServiceHost指令（Directive）,该指令具有一个必须的Service属性和一些可选的属性。所以最简单的.svc仅仅包含Service属性（该属性指明了相应的WCF服务的有效类型）的ServiceHost指令。
我是皇上，我怕谁 2018/08/30 20:04:38
最简单的.svc文件如下:
<%@ServiceHost Service= " Artech .WcfServices . Services .Calculatorservice"%> ;
我是皇上，我怕谁 2018/08/30 20:31:32
一个Web应用程序在运行的时候，默认从位于根目录下Bin目录加载程序集。然而编译的时候，默认情况下，编译后的程序集会自动保存到Bin/Debug/Release目录下。所以通过VS修改项目属性，将编译输出目录设置成Bin。
我是皇上，我怕谁 2018/09/03 09:26:35
服务寄宿将服务描述通过【元数据的形式】发布出来，相应的客户端就可以获取这些元数据，创建客户端程序进行服务的消费。所以，“添加服务用(AddService References)" ，在地址栏上键入【服务元数据】发布的源地址: http://127.0.0.1:9999/clalatorserice/metadata，并指定一个命名空间，点击OK按钮，VS为你生成一系列用于服务调用的代码和配置。
我是皇上，我怕谁 2018/09/04 18:55:20
在运行服务寄宿程序的情况下，添加服务引用。
我是皇上，我怕谁 2018/09/05 08:52:11
WCF的提供者（service provider）即宿主，将服务通过一个或多个终结点发布给潜在的服务消费者（service consumer）。
我是皇上，我怕谁 2018/09/05 08:53:31
服务消费者则通过与之匹配的终结点对服务进行消费。
我是皇上，我怕谁 2018/09/05 08:56:53
终结点三要素:
1、地址:定位一个服务的位置；
2、绑定:提供寻址（Addressing）的辅助信息；
3、契约:标识服务的真实身份；
我是皇上，我怕谁 2018/09/10 09:06:50
Soap消息由一个消息主体（Body）和若干消息报头(Header)组成。
我是皇上，我怕谁 2018/09/10 19:28:21
RESTful WCF服务无须遵循严格的消息格式，所以它采用单纯XML格式(POX:Plain Of XML)消息。
我是皇上，我怕谁 2018/09/11 08:30:39
在一个分布式应用环境中，安全(Security)往往是最重要的，同时也是最难实现的功能。
我是皇上，我怕谁 2018/09/11 08:42:19
对于一个安全系统(Security Infrastructure)来说,身份的识别或身份的验证(Identity Authentication)往往又是整个安全框架的基础。
我是皇上，我怕谁 2018/09/11 08:44:55
在对服务进行调用之前确定服务的真实身份同样是必不可少的。关于“双向验证”后续再提。
我是皇上，我怕谁 2018/09/12 08:56:57
HTTP协议具有如下特点:
1、HTTP提供简单的请求/回复(request/reply)消息传输方式；
2、HTTP是无状态的，每次HTTP请求都是相互独立的；
3、HTTP是无连接的，基于HTTP的数据传输无须事先打开连接；
我是皇上，我怕谁 2018/09/12 19:21:48
HTTP和HTTPS的URI分别使用http和https作为传输协议前缀(scheme),它们默认使用的端口分别为80和443，下面两组URI是等效的:
加端口号
http://artch.com:80/index.html
https://artch.com:443/index.html
与
不加端口号
http://artch.com/index.html
https://artch.com/index.html

等效
我是皇上，我怕谁 2018/09/13 19:03:42
IPC(Inter Process Communication),同一台机器上不同进程之间的通信，WCF有专门的实现方式:命名管道(Named Pipes)。
我是皇上，我怕谁 2018/09/13 19:15:41
虽然命名管道本身可以实现跨机器的通信，但是WCF却将命名管道专门用于同一台机器的跨进程通信，所以基于IPC的URI的主机名称或域名或IP地址部分只能是本机的机器名或者是localhost或127.0.0.1
我是皇上，我怕谁 2018/09/15 13:20:13
基于IPC的URI,都具有net.pipe前缀。在基于同一台机器的不同进程间通信中，端口没有任何意义。eg:
net.pipe://127.0.0.1/myservices/Calculator
我是皇上，我怕谁 2018/09/17 19:41:35
Net.Msmq URI
      消息队列(Messge Quecuing,也称MSMQ),是微软对消息服务领域的开创性尝试。由于消息队列采用了特殊的通信机制，对于改善和提高系统的可扩展性（Scalability）和高可用性(High Availability）具有重要的意义。消息队列按照可访问性可分为两种类型的队列。
      1、公共消息队列:公共消息队列发布于活动目录(AD: Active Directory) 列表中，井被复制到Windows域(Domain)。因为可以在不知道队列所在机器名称的情况下对公共队列进行检索，因而将公共队列从一台计算机移到另一台上，并不会对客户端应用造成影响。
      2、私有消息队列:私有消息队列一般在没有AD的工作组(Workgroup) 环境中使用，它们不支持身份验证，并且需要队列所在的计算机名称方能定位。
      WCF下，基于消息队列的URI,具有net.msmq前缀。net.msmq地址中须要指明队列的类型(公有队列: public 私有队列: private)。 由于默认为公有队列。所以对于公有队列，队列类型部分可以省略。
    net.msmq://artech.com/myservice(公有队列) 
net.msmq://artech.com/private/myservices (私有队)
我是皇上，我怕谁 2018/09/20 08:38:13
WCF服务自我寄宿与IIS寄宿不同，IIS寄宿的方式必须要为服务创建一个.svc文件。服务消费者通过访问.svc文件进行服务的调用，所以该.svc文件就是服务的地址，所以无需再通过配置指定终结点的地址。
我是皇上，我怕谁 2018/09/20 08:50:17
WCF中基地址和相对地址:对于一个服务来说，可以指定一个或多个基地址，但是对于一种传输协议类型（Scheme）,只能具有一个唯一的地址。
我是皇上，我怕谁 2018/09/21 09:16:56
WCF终结点中如果指定的是相对地址，那么WCF系统就会根据“绑定”采用的传输协议，然后在基地址列表中寻找与之匹配的基地址，相对地址和基地址结合确定终结点的绝对地址。
我是皇上，我怕谁 2018/09/21 09:31:55
由于基地址和相对地址匹配的关系是根据绑定对象采用的传输协议确定的，所以对于一个确定的传输协议，最多只能有一个基地址。
我是皇上，我怕谁 2018/09/21 09:52:30
WCF配置注意:
如果采用了代码和配置文件的方式，两者都会生效，所以必须确保两者设置的内容不能相互冲突。配置重复了，会报“ArgumentException”异常。
我是皇上，我怕谁 2018/09/26 08:45:30
对于基于同一个服务的若干终结点来讲，服务一般只实现唯一一个契约，所以所有终结点共享相同的服务契约。
我是皇上，我怕谁 2018/09/27 08:44:39
WCF中终结点的绑定对象，它的根本功能是提供基于通信的实现，WCF系统通过绑定对象构建一个信道栈(Channel Stack),创建了一座通信的桥梁。
我是皇上，我怕谁 2018/09/27 09:22:50
从上述的意义，同一服务下指定两个终结点(服务实现不同的契约，契约不同的两个终结点)，通过配置指定的两个终结点使用的是同一个信道栈。
我是皇上，我怕谁 2018/09/27 19:21:19
WCF在客户端，有两种常见的服务调用方式:
第一种方式，通过代码生成器(比如SvcUtil.exe)或添加服务引用导入元数据生成服务代理类型。
另一种方式，则是通过ChannelFactory<T>或DuplexChannelFactory<T>直接创建服务代理对象。
我是皇上，我怕谁 2018/10/08 09:27:34
WCF中如果终结点的所有配置项都通过配置方式提供，就可以通过终结点配置名称创建继承于ClientBase<TChannel>的服务代理的客户端类的对象。如果基于服务的终结点在配置中是唯一的，设置还可以不用指定任何参数。详情见P63。
我是皇上，我怕谁 2018/10/11 08:44:30
WCF是一个基于消息的通信框架，具有一个消息处理管道。消息流到该管道不同的位置，要对消息进行相应的处理。虽然基于REST/POX的WebServeice越来越流行，但是基于SOAP的WebService还是主流。
我是皇上，我怕谁 2018/10/11 08:54:31
SOAP已经成为了WebService事实上的标准，SOAP同时也是整个WS-*体系结构的基础。
我是皇上，我怕谁 2018/10/11 21:44:59
SOAP如今的地位，得益于可扩展的SOAP消息结构:SOAP报头+消息主体。我们可以把各种各样的控制信息置于SOAP封装(Envelope)的报头集合中，各种WS-*协议（比如WS-Addressing、WS-Reliable Messaging、WS-Security等）通过定义各自的SOAP报头得以实现
我是皇上，我怕谁 2018/10/13 08:49:42
典型的寻址相关的报头包含:<wsa: To>、<wsa: Via>、<wsa: ReplyTo>等。
我是皇上，我怕谁 2018/10/13 09:14:50
路由:就是导航。对于MVC请求，将导航到对应的处理程序反馈结果；对于网络中的路由，将数据引导流入指定的设备。
我是皇上，我怕谁 2018/10/18 08:33:55
using (ServiceHost servicehost = new ServiceHost (typeof(ICalculacorService)))
{
      string headervalue = "Licenaed User";
     string headerName = "UserType";

      string headerNamespace = "http: //www.artech. com";
      AddressHeader addressHeader = AddressHeader.CreateAddressHeader(headerName,headerNamespace , headerValue) ;
      EndpointAddress endpointAddress = new EndpointAddress(new Uri("http://127.0.0.1:999/CalculatorService"),addreasHeader);
  ServiceEndpoint serviceEndpoint = new ServiceEndpoint(Contract.Description.GetContract(typeof(ICalculator)),new BasicHttpBinding() , endpointAddress);
      ServiceHost.Description.Endpoints.Add(serviceEndpoint);
serviceHost.Open();
//其它代码
}

我是皇上，我怕谁 2018/10/18 08:37:22
以上代码:通过代码的方式为服务指定AddressHeader
